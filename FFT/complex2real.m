function [Y,t] = complex2real(F,t)% [Y,t] = complex2real(F, [t])%% Returns the real-valued amplitudes and phases in a structure calculated% from the complex-valued vector 'F' having the convention of fft's output.% This is the inverse of the function 'real2complex.m'.%% Inputs:%   F            Complex-valued vector in the convention of fft's output.%                (i.e., fft(y) )%%   t            Time vector of size y (default: 1:length(F) )%% Outputs:   %   Y            A structure with fields:%       dc       Mean value of y%       amp      Vector of amplitudes (length ceil(length(t)/2))%       ph       Vector of phases (in degrees, cosine phase)%       nt       Length of t (required for real2complex.m)%%   t            Time vector of size y, if not previously provided% SEE ALSO    real2complex fft ifft%% Example:%% t = 0:0.01:0.99;% y = t < 0.5; % Y = complex2real(fft(y),t);% clf; subplot(1,2,1); stem(t,y);% xlabel('Time (s)');% subplot(1,2,2); stem(Y.freq, Y.amp);% xlabel('Frequency (Hz)')% Written by G.M. Boynton at the University of Washington - 4/15/09% Edited by Kelly Chang - November 27, 2017%% Input Controlif ~exist('t', 'var') || isempty(t)    t = 1:length(F);end%% Transform Signal 'y' into Fourier Components% Calculate values based on tnt = length(t);dt = t(2)-t(1);% DC is first value scaled by ntdc = F(1)/nt;% 'real' amplitudes scale the fft by 2/ntamp = 2*abs(F)/nt;% 'real' phases are reversed (and converted to degrees)ph = -180*angle(F)/pi;% Pull out the first half (omitting 'negative' frequencies)id = 2:(ceil(nt/2)+1);if size(F,2) == 1;    id = id';end% Stuff the values in to the fields of YY.dc = dc;Y.ph = ph(id); %cosine phaseY.amp = amp(id);Y.freq = (1:length(id))/(nt*dt);if size(F,2) == 1;    Y.freq = Y.freq';end%Hack to deal with even vs. odd lengths of time seriesif mod(nt,2) %length is odd    Y.amp(end) = 0;else %length is even    Y.amp(end) = Y.amp(end)/2;endY.nt= nt;